
.macro acc8i16
	sep #$20
	.a8
	.i16
.endmacro

.macro acc16i16
	rep #$30
	.a16
	.i16
.endmacro

.macro acc8i8
	sep #$30
	.a8
	.i8
.endmacro

.macro acc16i8
	sep #$10
	.a16
	.i8
.endmacro

.macro Store32 v, d
.if (.match (.left (1, {v}), #))
  ; immediate mode
  lda #.loword(.right (.tcount ({v})-1, {v}))
.else
  lda v
.endif
  sta d
.if (.match (.left (1, {v}), #))
  lda #.hiword(.right (.tcount ({v})-1, {v}))
.else
  lda v+2
.endif
  sta d+2
.endmacro

.macro Add32 OP1, OP2, DEST
  .local no_carry
  clc
.if (.match (.left (1, {OP1}), #))
  lda #.loword(.right (.tcount ({OP1})-1, {OP1}))
.else
  lda OP1
.endif  
.if (.match (.left (1, {OP2}), #))
  adc #.loword(.right (.tcount ({OP2})-1, {OP2}))
.else
  adc OP2
.endif  
  sta DEST
  bcc no_carry
  inc DEST
no_carry:
.if (.match (.left (1, {OP1}), #))
  lda #.hiword(.right (.tcount ({OP1})-1, {OP1}))
.else
  lda OP1+2
.endif  
.if (.match (.left (1, {OP2}), #))
  adc #.hiword(.right (.tcount ({OP2})-1, {OP2}))
.else
  adc OP2+2
.endif  
  sta DEST+2
.endmacro

.macro Sub32 OP1, OP2, DEST
  .local no_carry
  sec
  lda OP1
  sbc OP2
  sta DEST
  bcs no_carry
  dec DEST
 no_carry:
  sec
  lda OP1+2
  sbc OP2+2
  sta DEST+2
.endmacro

.macro AdjustAddr
;  working_addr -= cur_segment_base;
;  working_addr += new_segment_base;
	Sub32 working_addr, cur_segment_base, working_addr
  Add32 working_addr, new_segment_base, working_addr
.endmacro

.macro PrgNext32To D
  jsr prg_next_word
  sta D
  jsr prg_next_word
  sta D+2
.endmacro

.macro PrgNext16To D
  jsr prg_next_word
  sta D
.endmacro

.macro PrgNext8To D
  jsr prg_next_byte
  acc8i16
  sta D
  acc16i16
.endmacro