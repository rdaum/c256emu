
.macro acc8i16
	sep #$20
	.a8
	.i16
.endmacro

.macro acc16i16
	rep #$30
	.a16
	.i16
.endmacro

.macro acc8i8
	sep #$30
	.a8
	.i8
.endmacro

.macro acc16i8
	sep #$10
	.a16
	.i8
.endmacro

.macro ProcStart
  pha  ; save working registers
  phx
  phy
  phd  ; save frame pointer and reset accordingly.
  tsc
  tcd
.endmacro

.macro ProcExit
  tdc
  tcs

  ; pop statically-allocated variables here,
  ; since they sit above the caller's D register.

  pld  ; remember to restore the previous caller's D register!
  ply
  plx
  pla
  rtl
.endmacro

.macro Store32 v, d
.if (.match (.left (1, {v}), #))
  ; immediate mode
  lda #.loword(.right (.tcount ({v})-1, {v}))
.else
  lda v
.endif
  sta d
.if (.match (.left (1, {v}), #))
  lda #.hiword(.right (.tcount ({v})-1, {v}))
.else
  lda v+2
.endif
  sta d+2
.endmacro

.macro Add32 OP1, OP2, DEST
  .local no_carry
  clc
.if (.match (.left (1, {OP1}), #))
  lda #.loword(.right (.tcount ({OP1})-1, {OP1}))
.else
  lda OP1
.endif  
.if (.match (.left (1, {OP2}), #))
  adc #.loword(.right (.tcount ({OP2})-1, {OP2}))
.else
  adc OP2
.endif  
  sta DEST
  bcc no_carry
  inc DEST
no_carry:
.if (.match (.left (1, {OP1}), #))
  lda #.hiword(.right (.tcount ({OP1})-1, {OP1}))
.else
  lda OP1+2
.endif  
.if (.match (.left (1, {OP2}), #))
  adc #.hiword(.right (.tcount ({OP2})-1, {OP2}))
.else
  adc OP2+2
.endif  
  sta DEST+2
.endmacro

.macro Sub32 OP1, OP2, DEST
  .local no_carry
  sec
  lda OP1
  sbc OP2
  sta DEST
  bcs no_carry
  dec DEST
 no_carry:
  sec
  lda OP1+2
  sbc OP2+2
  sta DEST+2
.endmacro

.macro AdjustAddr
;  working_addr -= cur_segment_base;
;  working_addr += new_segment_base;
	Sub32 working_addr, cur_segment_base, working_addr
  Add32 working_addr, new_segment_base, working_addr
.endmacro

.macro CopyBytesUnrolled source, dest, count
  .repeat count, N
    lda [source+N*2]
    sta [dest+N*2]
    lda [source+(N*2)+2]
    sta [dest+(N*2)+2]
  .endrep
.endmacro

.macro PrgNext32To D
  jsr prg_next_word
  sta D
  jsr prg_next_word
  sta D+2
.endmacro

.macro PrgNext16To D
  jsr prg_next_word
  sta D
.endmacro

.macro PrgNext8To D
  jsr prg_next_byte
  acc8i16
  sta D
  acc16i16
.endmacro