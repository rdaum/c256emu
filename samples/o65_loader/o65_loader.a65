.p816

.include "macros.a65"

.import __ZEROPAGE_LOAD__    ; symbol defining the start of the ZP

.zeropage
.org $00  
  status:            .res 1  ; 0 if ok, otherwise some error code
  program:           .res 4  ; ptr to bottom of program bank
  program_offset:    .res 2

  ; relocations working area
  cur_segment_base:  .res 4  ; the current segment base for reloc
  new_segment_base:  .res 4  ; desired segment base
  working_addr:      .res 4  ; where to stash relocated addresses

  ; read from the header
  mode:              .res 2
  tbase:             .res 4
  tlen:              .res 4
  dbase:             .res 4
  dlen:              .res 4
  bbase:             .res 4
  blen:              .res 4
  zbase:             .res 4
  zlen:              .res 4
  stack:             .res 4

  ; header options working area
  olen:              .res 1
  otype:             .res 1

  ; ext references working area
  num_references:    .res 4

ADDER32_A = $000120
ADDER32_B = $000124
ADDER32_R = $000128

.code
.org $10000
Start:
  ProcStart

	; set zero page to where the linker tells us it should be
	acc16i16
	lda #__ZEROPAGE_LOAD__
	tcd

  ; clear zero page vars
  acc8i16
  stz status
  stz olen
  stz otype

  acc16i16
  stz program_offset

  stz cur_segment_base
  stz cur_segment_base+2
  stz new_segment_base
  stz new_segment_base+2
  stz working_addr
  stz working_addr+2

  Store32 #$20000, program

step_load_header:
  jsl load_header         ; load the header
  acc8i16
  clc
  lda status
  cmp #0
  acc16i16
  beq step_load_header_options
  jml done
step_load_header_options:  
  jsl load_header_options ; eat the header options
  acc8i16
  clc
  lda status
  cmp #0
  acc16i16
  beq step_jump_past_segments
  jml done
step_jump_past_segments:
  ; program = program + program_offset, c256 32 bit adder used
  Store32 program, f:ADDER32_A
  lda program_offset
  sta f:ADDER32_B
  lda #$0000
  sta f:ADDER32_B+2
  lda f:ADDER32_R
  sta program
  lda f:ADDER32_R+2
  sta program+2
  stz program_offset

  ; jump offset by tlen+dlen
  Store32 program, f:ADDER32_A
  Store32 tlen, f:ADDER32_B
  lda f:ADDER32_R
  sta program
  lda f:ADDER32_R+2
  sta program+2
  Store32 program, f:ADDER32_A
  Store32 dlen, f:ADDER32_B
  lda f:ADDER32_R
  sta program
  lda f:ADDER32_R+2
  sta program+2

step_load_external_references:
  ; We've jumped to the start of the external references list
  ; eat that
  jsl load_external_references
  acc8i16
  clc
  lda status
  cmp #0
  acc16i16
  beq step_perform_relocations
  jml done
step_perform_relocations:

done:
  ProcExit

O65_BAD_HEADER_MAGIC = $01

prg_next_byte:
.scope
; Read current value @ program, put in A.
; corrupts Y
; Then increment program to next position
  acc16i16
  lda #0000
  lda program_offset
  tay
  acc8i16
  lda [program],Y
  acc16i16
  tay
  lda program_offset
  clc
  adc #1
  sta program_offset
  bcc done
  lda program+2
  inc
  sta program+2
done:
  tya
  rtl

.endscope

prg_next_word:
.scope
  lda program_offset
  tay
  lda #0000
  lda [program], Y
  tay
  lda program_offset
  clc
  adc #2
  sta program_offset
  bcc done
  lda program+2
  inc
  sta program+2
done:
  tya
  rtl

.endscope

load_header:
.scope

  ; First two bytes must be $01 $00 for non-c64
  jsl prg_next_word
  cmp #$0001
  bne fail_bad_magic

  ; Next 4 bytes should be 'o65\0' ($65 $36 $35 $00)
  jsl prg_next_word
  cmp #$366f
  bne fail_bad_magic
  jsl prg_next_word
  cmp #$0035
  beq good_magic

fail_bad_magic:
  acc8i16
  lda #O65_BAD_HEADER_MAGIC
  sta status
  acc16i16
  rtl

good_magic:
  jsl prg_next_word
  sta mode

  and #$2000
  cmp #$2000
  bne read_16_sizes

  PrgNext32To tbase
  PrgNext32To tlen
  PrgNext32To dbase
  PrgNext32To dlen
  PrgNext32To bbase
  PrgNext32To blen
  PrgNext32To zbase
  PrgNext32To zlen
  PrgNext32To stack
  bra done

read_16_sizes:
  PrgNext16To tbase
  PrgNext16To tlen
  PrgNext16To dbase
  PrgNext16To dlen
  PrgNext16To bbase
  PrgNext16To blen
  PrgNext16To zbase
  PrgNext16To zlen
  PrgNext16To stack

done:
  rtl

.endscope

load_header_options:
.scope
  
;  while ((olen = *(program++))) {
start_loop:
  clc
  PrgNext8To olen
  cmp #0
	bne start_header_option
  brl done
start_header_option:
;    uint8_t otype = *(program++);
;    olen -= 2;  // take out len and type bytes from count
  PrgNext8To otype
  acc8i16
  dec olen

read_header_option:
  acc8i16
  dec olen
  lda olen
  cmp #0
  bne eat_header_bytes
  brl start_loop
eat_header_bytes:
  jsl prg_next_byte
  bra read_header_option
done:
  acc16i16
	rtl

.endscope

load_external_references:
.scope
  clc
  lda mode
  and #$2000
  cmp #$2000
  bne read_num_refs_16
  stz num_references
  stz num_references+2
read_num_refs_32:
  PrgNext32To num_references
  bra eat_references_loop
read_num_refs_16:
  PrgNext16To num_references
eat_references_loop:
  lda num_references
  cmp #0
  beq done
  inc num_references
  jsr prg_next_byte
  cmp #0
  beq eat_references_loop
done:
  rtl

.endscope
