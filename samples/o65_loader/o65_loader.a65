.p816

.include "macros.a65"

.import __ZEROPAGE_LOAD__    ; symbol defining the start of the ZP

.zeropage
.org $00  
  status:            .res 1  ; 0 if ok, otherwise some error code
  program:           .res 4  ; ptr to bottom of program bank
  program_offset:    .res 2
  seg_base:          .res 4

  ; relocations working area 
  offset:            .res 4
  type:              .res 1
  segment:           .res 1
  cur_segment_base:  .res 4  ; the current segment base for reloc
  new_segment_base:  .res 4  ; desired segment base
  working_addr:      .res 4  ; where to stash relocated addresses

  ; read from the header
  mode:              .res 2
  tbase:             .res 4
  tlen:              .res 4
  dbase:             .res 4
  dlen:              .res 4
  bbase:             .res 4
  blen:              .res 4
  zbase:             .res 4
  zlen:              .res 4
  stack:             .res 4

  ; header options working area
  olen:              .res 1
  otype:             .res 1

  ; ext references working area
  num_references:    .res 4

ADDER32_A = $000120
ADDER32_B = $000124
ADDER32_R = $000128

TEXT_SEGMENT = 2
DATA_SEGMENT = 3
BSS_SEGMENT = 4
ZP_SEGMENT = 5

RELOC_WORD = $80
RELOC_HIGH = $40
RELOC_LOW = $20
RELOC_SEGADDR = $c0
RELOC_SEG = $a0

O65_BAD_HEADER_MAGIC = $01
O65_UNKNOWN_RELOC_SEGMENT = $02
O65_UNKNOWN_RELOC_TYPE = $03

.code
.org $10000


Start:
  ProcStart

	; set zero page to where the linker tells us it should be
	acc16i16
	lda #__ZEROPAGE_LOAD__
	tcd

  ; clear zero page vars
  acc8i16
  stz status
  stz olen
  stz otype

  acc16i16
  stz program_offset

  stz cur_segment_base
  stz cur_segment_base+2
  stz new_segment_base
  stz new_segment_base+2
  stz working_addr
  stz working_addr+2

  Store32 #$20000, program

step_load_header:
  jsl load_header         ; load the header
  acc8i16
  clc
  lda status
  cmp #0
  acc16i16
  beq step_load_header_options
  jml done
step_load_header_options:  
  jsl load_header_options ; eat the header options
  acc8i16
  clc
  lda status
  cmp #0
  acc16i16
  beq store_seg_base
  jml done
store_seg_base:  
  ; program = program + program_offset, c256 32 bit adder used
  Store32 program, f:ADDER32_A
  lda program_offset
  sta f:ADDER32_B
  lda #$0000
  sta f:ADDER32_B+2
  Store32 ADDER32_R, program
  stz program_offset

  ; stash that in seg_base
  Store32 program, seg_base

step_jump_past_segments:
  ; jump offset by tlen+dlen
  Store32 program, f:ADDER32_A
  Store32 tlen, f:ADDER32_B
  lda f:ADDER32_R
  sta program
  lda f:ADDER32_R+2
  sta program+2
  Store32 program, f:ADDER32_A
  Store32 dlen, f:ADDER32_B
  lda f:ADDER32_R
  sta program
  lda f:ADDER32_R+2
  sta program+2

step_load_external_references:
  ; We've jumped to the start of the external references list
  ; eat that
  jsl load_external_references
  acc8i16
  clc
  lda status
  cmp #0
  acc16i16
  beq step_perform_text_relocations
  jml done
step_perform_text_relocations:
  jsl perform_relocations     ; perform text seg relocations
  acc8i16
  clc
  lda status
  cmp #0
  acc16i16
  beq step_perform_data_relocations
  jml done
step_perform_data_relocations:
  jsl perform_relocations
  acc8i16
  clc
  lda status
  cmp #0
  acc16i16
  beq step_perform_bss_clear
  jml done
step_perform_bss_clear:
step_execute_program:
  jsl seg_base
done:
  ProcExit


; util functions

prg_next_byte:
.scope
; Read current value @ program, put in A.
; corrupts Y
; Then increment program to next position
  acc16i16
  lda #0000
  lda program_offset
  tay
  acc8i16
  lda [program],Y
  acc16i16
  tay
  lda program_offset
  clc
  adc #1
  sta program_offset
  bcc done
  lda program+2
  inc
  sta program+2
done:
  tya
  rtl

.endscope

prg_next_word:
.scope
  lda program_offset
  tay
  lda #0000
  lda [program], Y
  tay
  lda program_offset
  clc
  adc #2
  sta program_offset
  bcc done
  lda program+2
  inc
  sta program+2
done:
  tya
  rtl

.endscope


load_header:
.scope

  ; First two bytes must be $01 $00 for non-c64
  jsl prg_next_word
  cmp #$0001
  bne fail_bad_magic

  ; Next 4 bytes should be 'o65\0' ($65 $36 $35 $00)
  jsl prg_next_word
  cmp #$366f
  bne fail_bad_magic
  jsl prg_next_word
  cmp #$0035
  beq good_magic

fail_bad_magic:
  acc8i16
  lda #O65_BAD_HEADER_MAGIC
  sta status
  acc16i16
  rtl

good_magic:
  jsl prg_next_word
  sta mode

  and #$2000
  cmp #$2000
  bne read_16_sizes

  PrgNext32To tbase
  PrgNext32To tlen
  PrgNext32To dbase
  PrgNext32To dlen
  PrgNext32To bbase
  PrgNext32To blen
  PrgNext32To zbase
  PrgNext32To zlen
  PrgNext32To stack
  bra done

read_16_sizes:
  PrgNext16To tbase
  PrgNext16To tlen
  PrgNext16To dbase
  PrgNext16To dlen
  PrgNext16To bbase
  PrgNext16To blen
  PrgNext16To zbase
  PrgNext16To zlen
  PrgNext16To stack

done:
  rtl

.endscope

load_header_options:
.scope
  
;  while ((olen = *(program++))) {
start_loop:
  clc
  PrgNext8To olen
  cmp #0
	bne start_header_option
  brl done
start_header_option:
;    uint8_t otype = *(program++);
;    olen -= 2;  // take out len and type bytes from count
  PrgNext8To otype
  acc8i16
  dec olen

read_header_option:
  acc8i16
  dec olen
  lda olen
  cmp #0
  bne eat_header_bytes
  brl start_loop
eat_header_bytes:
  jsl prg_next_byte
  bra read_header_option
done:
  acc16i16
	rtl

.endscope

load_external_references:
.scope
  clc
  lda mode
  and #$2000
  cmp #$2000
  bne read_num_refs_16
  stz num_references
  stz num_references+2
read_num_refs_32:
  PrgNext32To num_references
  bra eat_references_loop
read_num_refs_16:
  PrgNext16To num_references
eat_references_loop:
  lda num_references
  cmp #0
  beq done
  inc num_references
  jsr prg_next_byte
  cmp #0
  beq eat_references_loop
done:
  rtl

.endscope

perform_relocations:
.scope
  stz offset
  stz offset+2
continue_relocations:
  clc
  jsl prg_next_byte
  cmp #0
  bne check_continue_offset
  jmp done
check_continue_offset:
  cmp #$ff            ; if 0xff add to the ongoing offset and go again
  bne accumulate_offset
  Store32 #$0000fe, ADDER32_A
  Store32 offset, ADDER32_B
  Store32 ADDER32_R, offset
  jmp perform_relocations

accumulate_offset:    
  sta ADDER32_A
  lda #$0000
  sta ADDER32_A+2
  Store32 offset, ADDER32_B
  Store32 ADDER32_R, offset  
get_type_and_segment:
  jsr prg_next_byte
  acc8i16
  tax
  and #$f0
  sta type
  txa
  and #$0f
  sta segment
start_text_seg_reloc:
  cmp #TEXT_SEGMENT
  bne start_data_seg_reloc
  ; do text seg reloc
  Store32 tbase, cur_segment_base
  Store32 seg_base, new_segment_base
  jsl do_reloc
  jmp continue_relocations
start_data_seg_reloc:
  cmp #DATA_SEGMENT
  bne start_zp_seg_reloc
  ; do data segment
  Store32 tbase, cur_segment_base
  Store32 seg_base, ADDER32_A
  Store32 tlen, ADDER32_B
  Store32 ADDER32_R, new_segment_base
  jsl do_reloc
  jmp continue_relocations
start_zp_seg_reloc:
  cmp #ZP_SEGMENT
  bne start_bss_seg_reloc
  ; do zp segment
  Store32 #$00000000, cur_segment_base
  Store32 zbase, new_segment_base
  jsl do_reloc
  jmp continue_relocations
start_bss_seg_reloc:
  cmp #BSS_SEGMENT
  bne unknown_segment_type
  ; do bss_reloc
  Store32 bbase, cur_segment_base
  Store32 seg_base, ADDER32_A
  Store32 tlen, ADDER32_B
  Store32 ADDER32_R, ADDER32_A
  Store32 dlen, ADDER32_B
  Store32 ADDER32_R, new_segment_base
  jsl do_reloc
  jmp continue_relocations
unknown_segment_type:
  acc8i16
  lda #O65_UNKNOWN_RELOC_SEGMENT
  sta status
  acc16i16
done:
  rtl
.endscope

do_reloc:
.scope
  acc16i8
  ldx type
  acc16i16
  stz working_addr
  stz working_addr+2
reloc_word:  
  cpx #RELOC_WORD
  bne reloc_seg
  ldy offset
  dey
  lda [seg_base],y          ; word = seg_base[offset-1]
  sta working_addr
  lda cur_segment_base+2
  sta working_addr+2     
  AdjustAddr
  lda working_addr
  sta [seg_base],y
  jmp done
reloc_seg: 
  cpx #RELOC_SEG
  bne reloc_segaddr
  jsr prg_next_byte       ; eat these two bytes,
  jsr prg_next_byte       ;  not sure what to do with them
  ldy offset
  dey
  acc8i16
  lda [seg_base],y
  sta working_addr+2
  acc16i16
  AdjustAddr
  lda working_addr
  sta [seg_base],y
  jmp done
reloc_segaddr:
  cpx #RELOC_SEGADDR
  bne reloc_low
  ldy offset
  iny
  acc8i16
  lda [seg_base],y
  sta working_addr+2
  acc16i16
  dey
  dey
  lda [seg_base],y
  sta working_addr
  AdjustAddr
  lda working_addr
  sta [seg_base],Y
  iny
  iny
  acc8i16
  lda working_addr+2
  sta [seg_base],Y
  acc16i16
  jmp done
reloc_low:
  cpx #RELOC_LOW
  bne reloc_high
  ldy offset
  dey
  lda [seg_base],y         
  sta working_addr
  Store32 working_addr, ADDER32_A
  Store32 cur_segment_base, ADDER32_B
  Store32 ADDER32_R, working_addr
  AdjustAddr
  acc8i16
  lda working_addr
  sta [seg_base],y
  acc16i16
  jmp done
reloc_high:
  cpx #RELOC_HIGH
  bne unknown_reloc_type
  ldy offset
  dey
  lda [seg_base],y
  sta working_addr+2
  Store32 working_addr, ADDER32_A
  Store32 cur_segment_base, ADDER32_B
  Store32 ADDER32_R, working_addr
  AdjustAddr
  acc8i16
  lda working_addr+1
  sta [seg_base],y
  acc16i16
  jsr prg_next_byte
  jmp done
unknown_reloc_type:
  acc8i16
  lda #O65_UNKNOWN_RELOC_TYPE
  sta status
  acc16i16
done:
  rtl

.endscope

