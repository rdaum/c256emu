.p816

.include "macros.a65"

.import __ZEROPAGE_LOAD__    ; symbol defining the start of the ZP

.zeropage
.org $00
  status:            .res 1  ; 0 if ok, otherwise some error code
  program:           .res 4  ; ptr to bottom of program bank
  program_offset:    .res 4

  ; for relocations
  cur_segment_base:  .res 4  ; the current segment base for reloc
  new_segment_base:  .res 4  ; desired segment base
  working_addr:      .res 4  ; where to stash relocated addresses

  ; read from the header
  mode:              .res 2
  tbase:             .res 4
  tlen:              .res 4
  dbase:             .res 4
  dlen:              .res 4
  bbase:             .res 4
  blen:              .res 4
  zbase:             .res 4
  zlen:              .res 4
  stack:             .res 4

  olen:              .res 1
  otype:             .res 1

.code
.org $10000
Start:
  ProcStart

	; set zero page to where the linker tells us it should be
	acc16i16
	lda #__ZEROPAGE_LOAD__
	tcd

  ; clear zero page vars
  acc8i16
  stz status
  stz olen
  stz otype

  acc16i16
  stz program_offset
  stz program_offset+2
  stz cur_segment_base
  stz cur_segment_base+2
  stz new_segment_base
  stz new_segment_base+2
  stz working_addr
  stz working_addr+2

  lda #.loword($20000)
  sta program
  lda #.hiword($20000)
  sta program+2

  jsl load_header         ; load the header
  jsl load_header_options ; eat the header options

  ProcExit

O65_BAD_HEADER_MAGIC = $01

prg_next_byte:
.scope
; Read current value @ program, put in A.
; corrupts Y
; Then increment program to next position
  acc16i16
  lda #0000
  lda program_offset
  tay
  acc8i16
  lda [program],Y
  acc16i16
  tay
  lda program_offset
  clc
  adc #1
  sta program_offset
  bcc done
  lda program+2
  inc
  sta program+2
done:
  tya
  rtl

.endscope

prg_next_word:
.scope
  lda program_offset
  tay
  lda #0000
  lda [program], Y
  tay
  lda program_offset
  clc
  adc #2
  sta program_offset
  bcc done
  lda program+2
  inc
  sta program+2
done:
  tya
  rtl

.endscope

load_header:
.scope

  ; First two bytes must be $01 $00 for non-c64
  jsl prg_next_word
  cmp #$0001
  bne fail_bad_magic

  ; Next 4 bytes should be 'o65\0' ($65 $36 $35 $00)
  jsl prg_next_word
  cmp #$366f
  bne fail_bad_magic
  jsl prg_next_word
  cmp #$0035
  beq good_magic

fail_bad_magic:
  acc8i16
  lda #O65_BAD_HEADER_MAGIC
  sta status
  acc16i16
  rtl

good_magic:
  jsl prg_next_word
  sta mode

  and #$2000
  cmp #$2000
  bne read_16_sizes

  PrgNext32To tbase
  PrgNext32To tlen
  PrgNext32To dbase
  PrgNext32To dlen
  PrgNext32To bbase
  PrgNext32To blen
  PrgNext32To zbase
  PrgNext32To zlen
  PrgNext32To stack
  bra done

read_16_sizes:
  PrgNext16To tbase
  PrgNext16To tlen
  PrgNext16To dbase
  PrgNext16To dlen
  PrgNext16To bbase
  PrgNext16To blen
  PrgNext16To zbase
  PrgNext16To zlen
  PrgNext16To stack

done:
  rtl

.endscope

load_header_options:
.scope
  
;  while ((olen = *(program++))) {
start_loop:
  clc
  PrgNext8To olen
  cmp #0
	bne start_header_option
  brl done
start_header_option:
;    uint8_t otype = *(program++);
;    olen -= 2;  // take out len and type bytes from count
  PrgNext8To otype
  acc8i16
  dec olen

read_header_option:
  acc8i16
  dec olen
  lda olen
  cmp #0
  bne eat_header_bytes
  brl start_loop
eat_header_bytes:
  jsl prg_next_byte
  bra read_header_option
done:
  acc16i16
	rtl

.endscope
